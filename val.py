# -*- coding: utf-8 -*-
"""email_validator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18rkvLKwkKVS9MJohisgbkEk5sMA0qTql

# ðŸ“¨ Enterprise-Grade Email Validator

This tool validates email addresses for leads, campaigns, and cold emails. It uses multiple layers of checks to ensure high accuracy while marking risky emails appropriately.

---

## **1. CSV Input Format**

- The CSV **must have a column named `Email`**.  
- Optional: any other columns are ignored.  

**Example:**

| Email                     |
|---------------------------|
| test@yopmail.com          |
| rest@example.com       |

- You can also enter emails manually (comma-separated).

---

## **2. Output CSV Format**

After validation, the CSV will contain:

| Column Name                | Values / Type                                | Description |
|-----------------------------|---------------------------------------------|-------------|
| **Email**                   | String                                      | Normalized email |
| **Syntax Valid**            | Yes / No                                    | Checks format correctness |
| **Domain Valid**            | Yes / No                                    | Checks if domain exists and has MX/A record |
| **Disposable**              | Yes / No                                    | Temporary/throwaway domains |
| **Role-Based**              | Yes / No                                    | Emails like admin@, support@, contact@ |
| **Catch-All Likely**        | Possible / No                               | Domain may accept all emails |
| **Domain Age (Days)**       | Integer / None                              | Domain age from WHOIS |
| **Provider**                | Google Workspace / Microsoft 365 / Zoho / Custom / Unknown | MX-record-based email provider |
| **SMTP Micro-Check**        | Success / Fail / Unknown                     | Simulated internal SMTP check |
| **DMARC/SPF Present**       | Yes / No                                    | Anti-spam protection present |
| **Bounce History Flag**     | Yes / No                                    | Flagged if email previously bounced |
| **RTPC Score**              | 0â€“100                                       | Real-Time Probability of Contact score |
| **Status**                  | DELIVERABLE / RISKY / NOT DELIVERABLE       | Overall result |
| **Reason**                  | Text                                        | Explanation for status |
| **Recommendation**          | SEND / DO NOT SEND                           | Suggested action |

---

## **3. Key Terms Explained**

- **Syntax Valid** â†’ Correct email format.  
- **Domain Valid** â†’ Domain exists with MX/A records.  
- **Disposable** â†’ Temporary email provider.  
- **Role-Based** â†’ Common business roles (admin@, support@, etc.)  
- **Catch-All Likely** â†’ Domain may accept all emails (cannot verify real inbox).  
- **Domain Age (Days)** â†’ Age of domain (new domains are riskier).  
- **Provider** â†’ Email host detected via MX records.  
- **SMTP Micro-Check** â†’ Checks deliverability using internal SMTP.  
- **DMARC/SPF Present** â†’ Anti-spam protection (higher confidence).  
- **Bounce History Flag** â†’ Seen in past bounce history.  
- **RTPC Score** â†’ Combined score based on all checks.  
- **Status** â†’ Deliverability status derived from RTPC.  
- **Reason** â†’ Why the email was marked risky/not deliverable.  
- **Recommendation** â†’ Suggested action: send or not send.

---

## **4. Usage in Colab**

1. Upload **disposable domains list** (file or Python list).  
2. Optionally upload **bounce history CSV**.  
3. Upload **email list CSV** or enter manually.  
4. Run the validation script.  
5. Download the output CSV/XLSX containing all validations.

> âœ… **Supports:** Multithreading, SMTP micro-checks, DMARC/SPF, disposable/role-based detection, domain age, internal bounce history, RTPC scoring.

---

## **5. Notes**

- Internal SMTP senders (`SMTP_LIST`) are used for safe micro-checks.  
- The system is **internal only**, no public sending is performed.  
- Very new domains (<7 days) are flagged as risky.  
- Medium-risk emails can be optionally treated as invalid (configurable).  
- Fully asynchronous and multi-threaded for high-volume processing (1M+ leads).
"""

# ================== INSTALL REQUIRED PACKAGES ==================
#!pip install pandas tqdm email-validator python-whois tldextract aiodns dnspython openpyxl --quiet

# Optional: if smtplib fails in Colab (rare)
# smtplib is part of Python stdlib, so no need to install
print("All required packages installed âœ…")

# ================== DISPOSABLE DOMAINS ==================
DISPOSABLE_DOMAINS = {
    "mailinator.com","10minutemail.com","10minutemail.net","10minutemail.org",
    "tempmail.com","temp-mail.org","guerrillamail.com","guerrillamail.org",
    "yopmail.com","yopmail.net","yopmail.fr","yopmail.gq","dispostable.com",
    "getairmail.com","trashmail.com","trashmail.net","mintemail.com",
    "throwawaymail.com","maildrop.cc","fakeinbox.com","spambog.com",
    "disposablemail.com","sharklasers.com","grr.la","mailnesia.com",
    "mailcatch.com","mytrashmail.com","moakt.com","emailondeck.com",
    "tempinbox.com","anonaddy.com","simplelogin.com","burnermail.io",
    "dropmail.me","inboxkitten.com","mailpoof.com","jetable.org",
    "trashmail.de","wegwerfemail.de","wegwerfmail.de","discard.email",
    "mail-temporaire.fr","tempr.email","spamgourmet.com","spam4.me",
    "spamex.com","spamavert.com","temporary-email.com",
    "throwawayemailaddress.com","mailmetrash.com","mailnull.com"
}

# ================== SMTP LIST ==================
SMTP_LIST = [
    "dev@meta-insyt.com",  # internal SMTP senders
    # Add more internal SMTP senders as needed
]

print(f"Loaded {len(DISPOSABLE_DOMAINS)} disposable domains")
print(f"Loaded {len(SMTP_LIST)} SMTP sender addresses")

# ================== IMPORTS ==================
import pandas as pd
import dns.resolver
import whois
import tldextract
from email_validator import validate_email, EmailNotValidError
from concurrent.futures import ThreadPoolExecutor, as_completed
from functools import lru_cache
from datetime import datetime
from tqdm import tqdm
from google.colab import files
import io
import threading
import random
import asyncio
import aiodns
import socket

# ================== CONFIG ==================
MAX_THREADS = 20
MIN_DOMAIN_AGE_INVALID = 7
MIN_DOMAIN_AGE_RISKY = 30
MERGE_RISKY_AS_INVALID = True  # treat medium-risk as invalid
ROLE_PREFIXES = {"admin","info","support","sales","contact","help","customercare","no-reply"}
# DISPOSABLE_FILE = "disposable_domains.txt"
# SMTP_LIST is already in memory from Cell 1
print(f"Using {len(SMTP_LIST)} SMTP senders from memory")

BOUNCE_HISTORY_FILE = None  # optional CSV file

# ================== THREAD LOCK ==================
print_lock = threading.Lock()
def log_status(msg):
    with print_lock:
        print(msg)

# ================== LOAD DISPOSABLE DOMAINS ==================
# Already loaded from Cell 1
print(f"Using {len(DISPOSABLE_DOMAINS)} disposable domains from memory")


# ================== LOAD BOUNCE HISTORY (OPTIONAL) ==================
BOUNCE_HISTORY = set()
print("Optional: Upload previous bounce history CSV with 'Email' column or skip")
uploaded_bounce = files.upload()
if uploaded_bounce:
    f = list(uploaded_bounce.keys())[0]
    df_bounce = pd.read_csv(io.BytesIO(uploaded_bounce[f]))
    if 'Email' in df_bounce.columns:
        BOUNCE_HISTORY = set(df_bounce['Email'].str.lower().dropna())
        print(f"Loaded {len(BOUNCE_HISTORY)} bounce history emails")

# ================== CACHED HELPERS ==================
@lru_cache(maxsize=10000)
def base_domain(email):
    ext = tldextract.extract(email.split("@")[1])
    return f"{ext.domain}.{ext.suffix}"

@lru_cache(maxsize=10000)
def has_mail_server(domain):
    try:
        dns.resolver.resolve(domain, "MX")
        return True
    except:
        try:
            dns.resolver.resolve(domain, "A")
            return True
        except:
            return False

@lru_cache(maxsize=5000)
def domain_age(domain):
    try:
        w = whois.whois(domain)
        c = w.creation_date
        if isinstance(c, list): c = c[0]
        if not c: return None
        return (datetime.utcnow() - c).days
    except:
        return None

@lru_cache(maxsize=5000)
def provider(domain):
    try:
        mx = str(dns.resolver.resolve(domain, "MX")[0].exchange).lower()
        if "google" in mx: return "Google Workspace"
        if "outlook" in mx or "microsoft" in mx: return "Microsoft 365"
        if "zoho" in mx: return "Zoho"
        return "Custom"
    except:
        return "Unknown"

def is_disposable(email):
    return base_domain(email).lower() in DISPOSABLE_DOMAINS

def is_role_based(email):
    return email.split('@')[0].lower() in ROLE_PREFIXES

def has_anti_spam(domain):
    try:
        dmarc_records = dns.resolver.resolve(f"_dmarc.{domain}", "TXT")
        spf_records = dns.resolver.resolve(domain, "TXT")
        dmarc_exists = any("v=DMARC1" in str(r) for r in dmarc_records)
        spf_exists = any("v=spf1" in str(r) for r in spf_records)
        return dmarc_exists or spf_exists
    except:
        return False

def check_smtp(email, smtp_sender):
    """Micro SMTP check using internal SMTP sender"""
    try:
        domain = email.split("@")[1]
        mx_records = dns.resolver.resolve(domain, 'MX')
        mx_host = str(mx_records[0].exchange)
        server = None
        import smtplib
        server = smtplib.SMTP(timeout=10)
        server.connect(mx_host)
        server.helo()
        server.mail(smtp_sender)
        code, _ = server.rcpt(email)
        server.quit()
        return code == 250
    except:
        return False

def calculate_rtpc_score(email, deliverable, disposable, role_based, anti_spam, bounce_history):
    score = 100
    if not deliverable:
        score -= 50
    if disposable:
        score -= 50
    if role_based:
        score -= 30
    if anti_spam:
        score -= 10
    if email.lower() in bounce_history:
        score -= 40
    return max(0, min(100, score))

# ================== EMAIL VALIDATION FUNCTION ==================
def validate_email_address(email):
    out = {
        "Email": email,
        "Syntax Valid": None,
        "Domain Valid": None,
        "Disposable": "No",
        "Role-Based": "No",
        "Catch-All Likely": "No",
        "Domain Age (Days)": None,
        "Provider": None,
        "SMTP Micro-Check": "Unknown",
        "DMARC/SPF Present": "No",
        "Bounce History Flag": "No",
        "RTPC Score": None,
        "Status": None,
        "Reason": "",
        "Recommendation": None
    }

    try:
        email_obj = validate_email(email).email
        out["Email"] = email_obj
        out["Syntax Valid"] = "Yes"
    except:
        out["Syntax Valid"] = "No"
        out["Status"] = "NOT DELIVERABLE"
        out["Reason"] = "Invalid syntax"
        out["Recommendation"] = "DO NOT SEND"
        return out

    dom = base_domain(email)
    out["Domain Valid"] = "Yes" if has_mail_server(dom) else "No"
    if out["Domain Valid"] == "No":
        out["Status"] = "NOT DELIVERABLE"
        out["Reason"] = "No mail server"
        out["Recommendation"] = "DO NOT SEND"
        return out

    # Disposable check
    if is_disposable(email):
        out["Disposable"] = "Yes"

    # Role-based check
    if is_role_based(email):
        out["Role-Based"] = "Yes"

    # Domain age
    age = domain_age(dom)
    out["Domain Age (Days)"] = age

    # Provider
    prov = provider(dom)
    out["Provider"] = prov
    if prov in {"Google Workspace","Microsoft 365","Zoho"}:
        out["Catch-All Likely"] = "Possible"

    # Anti-spam
    anti_spam = has_anti_spam(dom)
    out["DMARC/SPF Present"] = "Yes" if anti_spam else "No"

    # Bounce history
    if email.lower() in BOUNCE_HISTORY:
        out["Bounce History Flag"] = "Yes"

    # SMTP micro-check (try with random SMTP sender)
    smtp_sender = random.choice(SMTP_LIST)
    deliverable = check_smtp(email, smtp_sender)
    out["SMTP Micro-Check"] = "Success" if deliverable else "Fail"

    # RTPC score
    rtpc = calculate_rtpc_score(email, deliverable, out["Disposable"]=="Yes", out["Role-Based"]=="Yes", anti_spam, BOUNCE_HISTORY)
    out["RTPC Score"] = rtpc

    # Status & recommendation
    if rtpc >= 81:
        out["Status"] = "DELIVERABLE"
        out["Recommendation"] = "SEND"
        out["Reason"] = "Passed all checks"
    elif rtpc >= 51:
        out["Status"] = "RISKY"
        out["Recommendation"] = "DO NOT SEND"
        out["Reason"] = "Medium confidence â€“ verify"
        if MERGE_RISKY_AS_INVALID:
            out["Status"] = "NOT DELIVERABLE"
    else:
        out["Status"] = "NOT DELIVERABLE"
        out["Recommendation"] = "DO NOT SEND"
        out["Reason"] = "Failed one or more checks"

    return out

# ================== CSV / MANUAL PROCESSING ==================
def process_csv(input_csv):
    try:
        df = pd.read_csv(input_csv)
        if "Email" not in df.columns:
            raise Exception("CSV must contain 'Email' column")
        emails = df['Email'].dropna().tolist()
        results = []
        with ThreadPoolExecutor(MAX_THREADS) as executor:
            futures = {executor.submit(validate_email_address, e): e for e in emails}
            for f in tqdm(as_completed(futures), total=len(futures), desc="Validating Emails"):
                results.append(f.result())
        return pd.DataFrame(results)
    except Exception as e:
        print(f"Error processing CSV: {e}")
        return None

# ================== GOOGLE COLAB INTERFACE ==================
def colab_upload_and_validate():
    print("Upload CSV file with 'Email' column (or skip for manual entry)")
    uploaded = files.upload()
    emails = []
    if uploaded:
        filename = list(uploaded.keys())[0]
        validated_df = process_csv(io.BytesIO(uploaded[filename]))
    else:
        raw_input = input("Enter emails (comma separated): ")
        emails = [e.strip() for e in raw_input.split(",") if e.strip()]
        validated_df = pd.DataFrame([validate_email_address(e) for e in tqdm(emails, desc="Manual Emails")])

    if validated_df is not None:
        csv_name = "email_validation_results.csv"
        xlsx_name = "email_validation_results.xlsx"
        validated_df.to_csv(csv_name, index=False)
        validated_df.to_excel(xlsx_name, index=False)
        print("\nValidation complete. Download files:")
        files.download(csv_name)
        files.download(xlsx_name)

# ================== RUN ==================
if __name__ == "__main__":
    colab_upload_and_validate()
# -*- coding: utf-8 -*-
"""email_validator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18rkvLKwkKVS9MJohisgbkEk5sMA0qTql

# ðŸ“¨ Enterprise-Grade Email Validator

This tool validates email addresses for leads, campaigns, and cold emails. It uses multiple layers of checks to ensure high accuracy while marking risky emails appropriately.

---

## **1. CSV Input Format**

- The CSV **must have a column named `Email`**.  
- Optional: any other columns are ignored.  

**Example:**

| Email                     |
|---------------------------|
| test@yopmail.com          |
| rest@example.com       |

- You can also enter emails manually (comma-separated).

---

## **2. Output CSV Format**

After validation, the CSV will contain:

| Column Name                | Values / Type                                | Description |
|-----------------------------|---------------------------------------------|-------------|
| **Email**                   | String                                      | Normalized email |
| **Syntax Valid**            | Yes / No                                    | Checks format correctness |
| **Domain Valid**            | Yes / No                                    | Checks if domain exists and has MX/A record |
| **Disposable**              | Yes / No                                    | Temporary/throwaway domains |
| **Role-Based**              | Yes / No                                    | Emails like admin@, support@, contact@ |
| **Catch-All Likely**        | Possible / No                               | Domain may accept all emails |
| **Domain Age (Days)**       | Integer / None                              | Domain age from WHOIS |
| **Provider**                | Google Workspace / Microsoft 365 / Zoho / Custom / Unknown | MX-record-based email provider |
| **SMTP Micro-Check**        | Success / Fail / Unknown                     | Simulated internal SMTP check |
| **DMARC/SPF Present**       | Yes / No                                    | Anti-spam protection present |
| **Bounce History Flag**     | Yes / No                                    | Flagged if email previously bounced |
| **RTPC Score**              | 0â€“100                                       | Real-Time Probability of Contact score |
| **Status**                  | DELIVERABLE / RISKY / NOT DELIVERABLE       | Overall result |
| **Reason**                  | Text                                        | Explanation for status |
| **Recommendation**          | SEND / DO NOT SEND                           | Suggested action |

---

## **3. Key Terms Explained**

- **Syntax Valid** â†’ Correct email format.  
- **Domain Valid** â†’ Domain exists with MX/A records.  
- **Disposable** â†’ Temporary email provider.  
- **Role-Based** â†’ Common business roles (admin@, support@, etc.)  
- **Catch-All Likely** â†’ Domain may accept all emails (cannot verify real inbox).  
- **Domain Age (Days)** â†’ Age of domain (new domains are riskier).  
- **Provider** â†’ Email host detected via MX records.  
- **SMTP Micro-Check** â†’ Checks deliverability using internal SMTP.  
- **DMARC/SPF Present** â†’ Anti-spam protection (higher confidence).  
- **Bounce History Flag** â†’ Seen in past bounce history.  
- **RTPC Score** â†’ Combined score based on all checks.  
- **Status** â†’ Deliverability status derived from RTPC.  
- **Reason** â†’ Why the email was marked risky/not deliverable.  
- **Recommendation** â†’ Suggested action: send or not send.

---

## **4. Usage in Colab**

1. Upload **disposable domains list** (file or Python list).  
2. Optionally upload **bounce history CSV**.  
3. Upload **email list CSV** or enter manually.  
4. Run the validation script.  
5. Download the output CSV/XLSX containing all validations.

> âœ… **Supports:** Multithreading, SMTP micro-checks, DMARC/SPF, disposable/role-based detection, domain age, internal bounce history, RTPC scoring.

---

## **5. Notes**

- Internal SMTP senders (`SMTP_LIST`) are used for safe micro-checks.  
- The system is **internal only**, no public sending is performed.  
- Very new domains (<7 days) are flagged as risky.  
- Medium-risk emails can be optionally treated as invalid (configurable).  
- Fully asynchronous and multi-threaded for high-volume processing (1M+ leads).
"""

# ================== INSTALL REQUIRED PACKAGES ==================
#!pip install pandas tqdm email-validator python-whois tldextract aiodns dnspython openpyxl --quiet

# Optional: if smtplib fails in Colab (rare)
# smtplib is part of Python stdlib, so no need to install
print("All required packages installed âœ…")

# ================== DISPOSABLE DOMAINS ==================
DISPOSABLE_DOMAINS = {
    "mailinator.com","10minutemail.com","10minutemail.net","10minutemail.org",
    "tempmail.com","temp-mail.org","guerrillamail.com","guerrillamail.org",
    "yopmail.com","yopmail.net","yopmail.fr","yopmail.gq","dispostable.com",
    "getairmail.com","trashmail.com","trashmail.net","mintemail.com",
    "throwawaymail.com","maildrop.cc","fakeinbox.com","spambog.com",
    "disposablemail.com","sharklasers.com","grr.la","mailnesia.com",
    "mailcatch.com","mytrashmail.com","moakt.com","emailondeck.com",
    "tempinbox.com","anonaddy.com","simplelogin.com","burnermail.io",
    "dropmail.me","inboxkitten.com","mailpoof.com","jetable.org",
    "trashmail.de","wegwerfemail.de","wegwerfmail.de","discard.email",
    "mail-temporaire.fr","tempr.email","spamgourmet.com","spam4.me",
    "spamex.com","spamavert.com","temporary-email.com",
    "throwawayemailaddress.com","mailmetrash.com","mailnull.com"
}

# ================== SMTP LIST ==================
SMTP_LIST = [
    "dev@meta-insyt.com",  # internal SMTP senders
    # Add more internal SMTP senders as needed
]

print(f"Loaded {len(DISPOSABLE_DOMAINS)} disposable domains")
print(f"Loaded {len(SMTP_LIST)} SMTP sender addresses")

# ==========================
# ENTERPRISE EMAIL VERIFIER v2
# Catch-All + Firewall Aware
# ==========================

import pandas as pd
import dns.resolver
import whois
import tldextract
import random
import smtplib
import socket
import string
import threading
from email_validator import validate_email
from concurrent.futures import ThreadPoolExecutor, as_completed
from functools import lru_cache
from datetime import datetime
from tqdm import tqdm
from google.colab import files
import io

# ================= CONFIG =================
MAX_THREADS = 15
SMTP_TIMEOUT = 10

# ----- Feature toggles -----
ENABLE_FIREWALL_DETECTION = True  # Set to False to skip firewall detection
ENABLE_DKIM_SPF_CHECK = True      # Set to False to skip DMARC/SPF/DKIM checks

ROLE_PREFIXES = {
    "admin","info","support","sales","contact","help","customercare","no-reply"
}

FIREWALL_KEYWORDS = {
    "proofpoint","barracuda","mimecast","cisco","forcepoint","sophos","trendmicro"
}

MIN_DOMAIN_AGE_INVALID = 7
MIN_DOMAIN_AGE_RISKY = 30

print_lock = threading.Lock()

# ================= HELPERS =================
@lru_cache(maxsize=10000)
def base_domain(email):
    ext = tldextract.extract(email.split("@")[1])
    return f"{ext.domain}.{ext.suffix}"

@lru_cache(maxsize=5000)
def resolve_mx(domain):
    try:
        return [str(r.exchange).lower() for r in dns.resolver.resolve(domain, "MX")]
    except:
        return []

def detect_firewall(mx_hosts):
    for mx in mx_hosts:
        for fw in FIREWALL_KEYWORDS:
            if fw in mx:
                return True, fw
    return False, None

@lru_cache(maxsize=5000)
def domain_age(domain):
    try:
        w = whois.whois(domain)
        c = w.creation_date
        if isinstance(c, list):
            c = c[0]
        if not c:
            return None
        return (datetime.utcnow() - c).days
    except:
        return None

def random_local():
    return ''.join(random.choices(string.ascii_lowercase, k=12))

def smtp_rcpt_check(mx, sender, rcpt):
    try:
        server = smtplib.SMTP(timeout=SMTP_TIMEOUT)
        server.connect(mx)
        server.helo()
        server.mail(sender)
        code, _ = server.rcpt(rcpt)
        server.quit()
        return code
    except:
        return None

def detect_catch_all(mx, domain, sender):
    fake1 = f"{random_local()}@{domain}"
    fake2 = f"{random_local()}@{domain}"

    r1 = smtp_rcpt_check(mx, sender, fake1)
    r2 = smtp_rcpt_check(mx, sender, fake2)

    if r1 == 250 and r2 == 250:
        return True
    return False

# ================= MAIN VALIDATION =================
def validate_email_address(email, smtp_sender):
    out = {
        "Email": email,
        "Syntax": "Invalid",
        "Domain": "Invalid",
        "Firewall": "No",
        "Catch-All": "No",
        "Domain Age (Days)": None,
        "Spammy": "No",
        "AsianRegion": "No",
        "SMTP Trust": "Unknown",
        "Confidence": 0,
        "Status": None,
        "Recommendation": None,
        "Reason": ""
    }

    # Syntax
    try:
        email = validate_email(email).email
        out["Email"] = email
        out["Syntax"] = "Valid"
    except:
        out["Status"] = "INVALID"
        out["Reason"] = "Bad syntax"
        out["Recommendation"] = "DO NOT SEND"
        return out

    domain = base_domain(email)
    mx_hosts = resolve_mx(domain)

    if not mx_hosts:
        out["Status"] = "INVALID"
        out["Reason"] = "No MX records"
        out["Recommendation"] = "DO NOT SEND"
        return out

    out["Domain"] = "Valid"

    # Firewall detection (optional)
    if ENABLE_FIREWALL_DETECTION:
        firewall, fw_name = detect_firewall(mx_hosts)
        if firewall:
            out["Firewall"] = f"Yes ({fw_name})"
    else:
        firewall, fw_name = False, None

    # Domain age
    age = domain_age(domain)
    # Spammy detection (using disposable domains as proxy)
    is_spammy = domain in DISPOSABLE_DOMAINS
    out["Spammy"] = "Yes" if is_spammy else "No"

    # Asian region detection via WHOIS country code
    try:
        w = whois.whois(domain)
        country = w.country
        asian_countries = {"CN", "JP", "KR", "IN", "SG", "TH", "MY", "ID", "PH", "VN", "HK", "TW"}
        is_asian = country in asian_countries if country else False
    except Exception:
        is_asian = False
    out["AsianRegion"] = "Yes" if is_asian else "No"

    # DMARC / SPF / DKIM detection (optional)
    if ENABLE_DKIM_SPF_CHECK:
        try:
            dmarc_records = dns.resolver.resolve(f"_dmarc.{domain}", "TXT")
            out["DMARC Present"] = "Yes"
        except Exception:
            out["DMARC Present"] = "No"
        try:
            spf_records = dns.resolver.resolve(domain, "TXT")
            spf_present = any(r.to_text().lower().startswith('v=spf1') for r in spf_records)
            out["SPF Present"] = "Yes" if spf_present else "No"
        except Exception:
            out["SPF Present"] = "No"
    else:
        out["DMARC Present"] = "Skipped"
        out["SPF Present"] = "Skipped"

    # SMTP RCPT for real email
    mx = mx_hosts[0]
    smtp_code = smtp_rcpt_check(mx, smtp_sender, email)

    # Catch-all test
    is_catch_all = detect_catch_all(mx, domain, smtp_sender)
    if is_catch_all:
        out["Catch-All"] = "Yes"

    # Trust logic
    smtp_trusted = True
    if firewall:
        smtp_trusted = False
    if smtp_code is None:
        smtp_trusted = False

    out["SMTP Trust"] = "Trusted" if smtp_trusted else "Untrusted"

    # ================= SCORING =================
    score = 100

    # Domain age penalty removed per user request

    if is_catch_all:
        score -= 35

    if firewall:
        score -= 30

    if smtp_code != 250:
        score -= 50

    score = max(0, min(100, score))
    out["Confidence"] = score

    # ================= FINAL STATUS =================
    if score >= 80 and not firewall and not is_catch_all:
        out["Status"] = "VALID"
        out["Recommendation"] = "SAFE TO SEND"
        out["Reason"] = "Mailbox level confidence"
    elif firewall:
        out["Status"] = "FIREWALL_PROTECTED"
        out["Recommendation"] = "SEND SLOW / WARMED IP ONLY"
        out["Reason"] = "Enterprise firewall hides mailbox status"
    elif is_catch_all:
        out["Status"] = "CATCH_ALL"
        out["Recommendation"] = "SEND ONLY IF NECESSARY"
        out["Reason"] = "Domain accepts all recipients"
    elif score >= 50:
        out["Status"] = "RISKY"
        out["Recommendation"] = "DO NOT BULK SEND"
        out["Reason"] = "Medium confidence"
    else:
        out["Status"] = "INVALID"
        out["Recommendation"] = "DO NOT SEND"
        out["Reason"] = "Low confidence"

    return out

# ================= CSV PROCESS =================
def process_csv(file_bytes, smtp_sender):
    df = pd.read_csv(file_bytes)
    if "Email" not in df.columns:
        raise Exception("CSV must contain Email column")

    emails = df["Email"].dropna().tolist()
    results = []

    with ThreadPoolExecutor(MAX_THREADS) as exe:
        futures = {
            exe.submit(validate_email_address, e, smtp_sender): e
            for e in emails
        }
        for f in tqdm(as_completed(futures), total=len(futures)):
            results.append(f.result())

    return pd.DataFrame(results)

# ================= COLAB UI =================
def run_colab():
    print("Upload CSV with Email column")
    uploaded = files.upload()
    if not uploaded:
        print("No file uploaded")
        return

    smtp_sender = input("Enter sender email for SMTP probing: ").strip()

    fname = list(uploaded.keys())[0]
    df = process_csv(io.BytesIO(uploaded[fname]), smtp_sender)

    df.to_csv("verified_results.csv", index=False)
    df.to_excel("verified_results.xlsx", index=False)

    files.download("verified_results.csv")
    files.download("verified_results.xlsx")

# ================= RUN =================
if __name__ == "__main__":
    run_colab()
